## 솔루션 아키텍처
- DNS LAYER: Route 53 (통신)
- CDN(콘텐츠 전송 네트워크) LAYER: CloudFront 정적 콘텐츠
- Static Assets Layer (storage): S3, Glacier
- Wdb Layer: CLB. ALB. NLB, API Gateway, Elastic IP
- Compute Layer: EC2, ASG, Lambda, ECS, Fargate, Batch, EMR
- DATABASE LAYER: RDS, Aurora, DynamoDB, ElasticSearch, S3
- Caching / Session Layer: ElastiCache, DAX, DynamoDB, RDS
- Storage LAYER: EBS, EFS, Instance Store
- Decoupling Orchestration Layer: SQS, SNS, Kinesis, Amazon MQ

## EC2
- 인스턴스 타입
    - R: RAM을 많이 사용하는 경우, in-memory cache
    - C: CPU 사용이 많을 경우, compute/ database
    - M: 균형맞춘 경우, general/ web app
    - I: 저장 등 로컬에 좋은 경우, database
    - G: GPU 필요시, 머신러닝, 비디어렌더링
    - T2/T3: 기본 성능이 필요할때
    - T2/T3 무제한: 특정 워크로드가 있을때 필요
- 배치 그룹
    - placement group을 통해서 전략을 새울 수가 있다
    - 클러스터: 동일한 az(availability zone) 안에 있는 모든 인스턴스를 클러스터화
    - 스프레드: 기반 하드웨어들에 걸쳐 인스턴스를 분산할때 사용. 최대 7개의 인스턴스, 하드웨어 고장이 없어야함. 분산하는 앱에 적합
    - 파티션: 인스턴스를 다양한 파티션에 걸쳐 배치. hadoop 카산드라 카프카 등이 있을때 사용
    - 그룹 이동시에는 멈춘 뒤에 cli에서 명령 후 시작해야함
- 클러스터 배치 그룹
    - 모든 인스턴스가 동일한 rack, AZ에 존재
    - 좋은 네트워크
    - 단점은 하나가 고장나면 모든게 고장
    - 향상된 네트워크에 사용
    - 빠르게 완료되어야 하는 고성능 연산 빅데이터 작업에 사용
- 스프레드 배치 그룹
    - 다양한 az에 걸쳐 다양한 하드웨어 존재
    - 각각의 ec2가 다른 하드웨어에 배치
    - az 당 최대 7개
    - 동시에 고장난 확률이 낮아짐
    - 스케일이 제한됨
    - 고가용성을 극대화하는 앱에 유리
- 파티션 배치 그룹
    - az가 다수의 파티션에 걸쳐 분할. ec2은 각각의 파티션에 배치됨
    - az당 최대 7개의 파티션. 파티션 내부의 ec2 내부의 인스턴스끼리는 랙을 공유하지 않음
- ec2 인스턴스 실행
    - on demand instance: 신뢰성을 얻고 싶은 경우
    - spot instance: 저렴한 인스턴스를 원하는 경우
    - reserved instance: 예약 인스턴스. 최소 1년, 장시간 워크로드 사용시에 필요
    - 변환 가능한 instance 예약: 최소 1년 시간이 지나면 인스턴스를 변경하려는 경우
    - dedicated instance: 다른 고객이랑 하드웨어를 공유하지 않음
    - dedicated host: 물리 서버 전체를 예약해 배치를 통제할 수 있음
        - ex) host affinity를 통한 인스턴스 재부팅 시 동일한 호스트로 구성
- graviton
    - ec2 인스턴스에게 최적의 가격대비 성능 제공
    - 최신형 인스턴스에 사용
    - linux ubuntu redhat 등 지원. window 미지원
    - graviton2는 가격 대비 성능이 40% 유리
- ec2에 포함된 metric
    - CPU, network, status_check, disk
    - ram은 포함되지 않음사용자 지정에서 cloudwatch로 푸시해야함
- ec2 인스턴스 복구
    - status check에서 인스턴스 상태, 시스템 상태를 알 수가 있음.
    - 장애 체크 시에 cloudwatch를 통해 복구 액션을 정의할 수가 있음

## 고성능 컴퓨팅 (HPC)
- aws의 어떤 서비스가 hpc에 도움이 될까
- data 관리: diret connect: 데이터를 클라우드로 전송하는 기술
- snowball snowmobile 규모가 큰 전송을 한꺼번에 해줌
- datasync: s3 등으로 전송하는데 사용됨
- 컴퓨팅과 네트워크
    - s3: 
        - cpy최적화, gpu 최적화 등이 있음
        - 스팟 인스턴스, 오토 스케일링을 통해서 코스트 절약
        - 클러스터 유형의 배치를 통해서 높은 속도의 네트워크 유지
        - SR-IOV (향상된 네트워크) 옵션 종류
            - ENA 옵션: elastic network adapter. 100 gbps 속도 제공. 높은 대역폭, 초당 패킷과 낮은 지연을 가짐
            - Intel 82599 VF 옵션: 10 gps까지 지원. 레거시 기능
            - EFA 옵션: elasti fabric adapter. HPC(고성능 컴퓨팅) 전용의 ENA. linux에서 작동. 노드간의 통신에 적합
                - 분산 워크로드에 적합
- storage
    - 인스턴스에 부착된 storage
        - EBS: 256000 iops 스케일링이 가능. 
        - instance store: 지연이 짧고 e2끼리 연결되어 있음. 인스턴스를 잃을때 같이 손실 될 수도 있음
    - network storage
        - amazon s3: 큰 blob, 파일 시스템은 아님
        - amazon EFS: iops를 사용
        - amazon fsx for lustre: hpc 최적화가 되어있고, s3에 의해 지원
- 자동화와 오케스크레이션
    - aws batch: 평행 작업을 수행. 일정을 조정할 수가 있으며, ec2 인스턴스 실행
    - aws parallelluster: hpc를 배포하는데 사용하는 툴
        - 텍스트로 config가 이루어지며 vpc 서브넷 생성 등을 자동화

## 오토 스케일링
- 동적 스케일링 정책
    - 대상 추적 스케일링
        - 단순 쉬움
        - 지표 하나를 가지고 값을 지정 후, 값이 높으면 인스턴스 추가, 낮으면 제거
    - step scaling
        - cloudwatch 경보에 따른 설정 행동을 함
    - scheduled ations
        - 특정 이벤트가 일어날 것을 예상해 특정 시점에 인스턴스 변화 이벤트 설정
    - 예측 스케일링
        - 미래의 로드를 예측해 일정을 미리 설정
        - AWS가 로드를 분석해 예측된 로드를 생성
- 지표
    - CPUUtilization: cpu 설정 비율만 가동하도록 설정
    - requestCountPerTarget: ec2 인스턴스당 지정된 request 개수만 응답하도록 설정
    - average network in/out: 지정된 네트워크 인/아웃 양을 설정
- 기타
    - 스팟 플릿 지원: 스팟과 온디맨드 인스턴스를 조합해 오토 스케일링 그ㅡ룹에 사용
    - 수명 주기 후크: 인스턴스 종료 전 작업을 수행. 로그 추ㅜㄹ 특별 상태 등
    - ami 업글을 위해서 launch config 설정 후 ec2 수동 종료하거나 ec2 오토 스케일링 새로 고침을 통해 종료
- 프로세스
    - launch: ec2 인스턴스를 그룹으로 추가해 용량 증가
    - terminate: 그룹으로부터 ec2 인스턴스 제거
    - healthcheck: 인스턴스 상태 점검
    - replaceUnhealthy: 비정상 인스턴스를 종료하고 재생성하는 프로세스
    - AZrebalance: AZ에서 EC2 개수가 가용 영역에 걸쳐 동등하게 있는지 확인 
    - alarmnotification: cloudwtch로부터 확인받음
    - scheduledAction: 스케일링을 위해 생성한 예약 동작 수행
    - AddToLoadbalancer: 로드 밸런서나 타켓 그룹으로 인스턴스를 추가해 줌
    - instanceRefresh: 모든 인스턴스를 종료하고 새로운 인스턴스 생성
- health check
    - ec2 상태 확인
    - 오토 스케일링 앞에 elb가 있는 경우 elb 상태 확인 (http 기반)
    - 인스턴스가 비정상이면 종료하고 새로운 인스턴스 시작

## EC2 
- spot instance
    - 온디멘드에 비해 90퍼까지 저렴
    - 최대 스팟 가격 지정 후 낮을 경우 인스턴스를 받음
    - 스팟 가격이 최대보다 높을 경우 중단, 종료 중 하나를 선택 가능
    - 스팟 인스턴스는 배치 잡, 데이터 분석, 복원력 높은 워크로드에 적합
    - 중요한 작업이나 db에 사용하면 안됨. aws에 의해 회수되고 손실될 수도 있음
- spot fleets
    - 스팟 인스턴스 집합 or 온디맨드 인스턴스의 집합
    - 최대 가격을 설정하고 여러 종류의 인스턴스를 혼합
    - 인스턴스 유형의 혼합이 가능. 계산력이 더 중요한 경우
    - 스팟 플릿을 사용해 대규모 워크로드 시작 가능
    - 최적의 비용을 선택해주기에 최대의 비용 절감 가능 (spot flttes = set of spot instance + on-demand instance)
    - spot istance 할당 전략
        - lowestprice: 가장 낮은 가격의 풀에서 인스턴스 시작, 비용 최적화와 짧은 워크로드에 유리
        - diversified: 시작이 정의한 풀 전체로 분산. 가용성과 긴 워크로드에 유리
        - capacityOptimized: 인스턴스 개수의 용량에 최적화

## AWS에서 docker 관리
- Amazon ECS를 통해서 관리(Elastic Container Service)
    - container platform
- Amazon EKS를 통해서 관리(Elastic Kubernetes Service)
    - kubernetes 관리
- AWS Fargate
    - ECS EKS와 호환
- ECS 예시
    - run microservice
        - 같은 머신에서 여러 docker 실행
        - 서비스 검색 기능 추가
        - alb(앱 로드 밸런서)와 nlc(네트워크 로드 밸런서)랑 직접 통합
        - 자동 확장
    - 배치 처리나 예약 작업
        - 온디멘드, 예약, 스팟 인스턴스로 ECS 작업이 이루어지게 예약
    - 클라우드 이전에도 유리
        - 앱을 도커화 한 후에 도커 컨테이너를 이전해서 ECS에서 실행
- ECS 개념
    - 클러스터: ec2 인스턴스를 그룹화
    - 서비스: 작업 개수와 방법을 결정
    - 테스크 정의: json 형태로 docker container에 대한 정보를 정의
    - ecs 테스크: 서비스 내부에서 실행되는 태스크 정의
    - iam role: ec2 instance profile, ecs task iam role 등이 존재
    - alb 통합
        - 동적 매핑 포트
            - 동일 ec2 인스턴스 내의 동일 도커 컨테이너, 동일 인스턴스 여럿을 함께 실행
            - alb는 다른 매핑 포트를 가져도 ec2에서 맞는 포트를 찾아 lb에 매핑
- Fragate에서의 docker
    - 인프라 프로비저닝과 ec2 인스턴스 관리 불필요
    - 모두 서버리스임
    - 테스크 별로 cpu ram 설정시 자동으로 생성
    - 확장은 테스크 개수를 늘리면 됨
- ECS 보안
    - none: 포트 매핑, 네트워크 연결이 없음
    - bridge: 가상의 컨테이너에 네트워크 연결
    - host: 기본 호스트 네트워크 인터페이스 사용
    - awsvpc: 모든 ECS 테스크에 각기 eni와 프라이빗 ip 주소 부여
- ECS 오토 스케일링
    - 백엔드에서 application auto scaling serviec 활용
    - epu and ram은 cloudwatch의 지표로 사용됨
    - 지표 목푯값을 기준 삼아 대상 추적 스케일링을 할 수가 있음 (단계 스케일링, 예약 스케일링으로 할 수도 있음)

## ECR (Elastic Container Registry)
- aws에서 docker 이미지를 저장하고 관리하는데 사용
- private, public 2개의 리포가 있음
- ecr에 있는 도커 이미지를 ecs에 있는 ec2가 자유롭게 댕겨올 수가 있음
- ecr ecs는 iam을 통해 연결되어있기에 문제 발생시 iam 정책 확인
- ecr에는 교차 리전과 교차 계정 복제 모두 지원
- 이미지 스캐닝 기능: 스캔해서 취약점을 찾음.
    - 기본 스캐닝: 공통 에러를 스캔. ecr이 담당
    - 고급 스캐닝: 운영체제와 프로그래밍 언어의 취약점을 탐색. inspector가 담당
    - 결과를 모두 콘솔에서 확인 가능

## EKS
- elastic kubernetes service의 약자
- 관리형 kubernetes 클러스터를 aws에서 실행
- ecs과 비슷하나 다름
    - ecs는 오픈소스가 아니지만 kubernetes는 오픈 소스
    - kuber는 각각의 ec2에 pod를 실행해 배포  
- eks는 ec2 같은 워커 모드를 배포하거나 fargate와 같이 서버리스에 배포할 수 있음
- kubernetes는 모든 클라우스에 사용 가능 (google azure amazon 등)
- 노드 타입
    - 관리형 노드 그룹
        - aws가 ec2 인스턴스를 생성하고 관리
        - eks 서비스를 관리하는 auto scaling 그룹의 일부분
        - 온디맨드와 스팟 인스턴스 지원
    - 셀프 관리 노드
        - 직접 노드 생성
        - 사전에 구축된 ami를 사용해서 시간 절약 가능
        - 온디맨드와 스팟 인스턴스 지원
    - fargate
        - 노드를 원하지 않을 시
        - 유지보수 불 필요
- eks에 data volumes 첨부
    - eks 클러스터에 storageclass 매니페스트 지정 필요
    - csi(container storage interface) 드라이버 사용

## aws app runner
- 컨테이너 이미지를 받아서 실행해주는 서비스
- 어떻게 실행할지에 대한 설정 구성
- ram cpu 수, auto sacling 등
- 한번의 클릭으로 생성하고 배포
- vpc 안에서 리소스에 액세스 가능
- db 캐시 메세지 큐에 연결 가능
- 이미지 뿐만이 아닌 python java 코드로도 가능
- route 53을 통해서 리전간 실행 가능

## ecs anywhere / eks anywhere
- ecs anywhere
    - 컨테이너를 손쉽게 실행
    - 어떤 환경, 어떤 태스크도 실행 가능
    - ecs container agent, ssm agent가 필요
    - external 타입이 필요
    - aws 리전에 안정적으로 연결되어 있어야함
- eks anywhere
    - 외부에서 쿠버네티스 클러스터를 실행
    - amazon eks distro를 활용
        - 지원 비용을 절약하고 불필요한 툴의 유지보수 지원
    - aws 접속하지 않아도 실행 가능
    - eks anywhere 설치 필요, 선택적으로 eks connector도 필요(aws에 연결할 경우)
    - 완전 접속 및 일부 비접속 모드
        - 온프레미스 데이터센터와 연결. eks 클러스터 관리
    - 완전 비접속 모드
        - aws 미연결, distro를 설치하고 온프레미스를 이용해서 관리

## aws lambda
- 함수를 호출해서 사용 가능
- 다양한 언어 지원
- cloudevent를 설정해서 매시간 실행되게 설정도 가능
- 한계점
    - 최대 10gb의 ram
    - cpu는 ram과 연결됨 (설정 불가)
    - 최장시간은 15분
    - 임시 저장소는 10gb
    - 배포 패키지는 압축했을 때 50mb, 비압축 상태는 250mb
    - 동시 실행은 최대 1000이 한계 (약간 늘려주는 소프트 리미트는 가능)
    - 컨테이너 하나의 최대 이미지 사이즈는 10gb
    - 호출 페이로드 동기 호출은 6mb, 비동기는 256kb
    - 동시성 이슈
        - 람다를 사용하는 alb와 api gateway가 있을 시
        - alb가 천개를 모두 사용하면 api를 전혀 사용하지 못함 -> 동시성을 걸어야함
- codedeploy를 통해서 람다 함수 배포 가능
    - sam 프레임워크 안에 통합되어 있음
    - linear 방식: n분마다 트래픽을 증가시켜 100 될때까지 반복
    - canary: 처음 n%가 성공하면 모든 트래픽 전환
    - allatonce: 즉시
- log
    - cloudwatch log에서 모든 로그 얻을 수 있음
        - cloudwatch에 정확히 엑세스 할 수 있는지 확인 필요
    - xray
        - 람다 함수 호출 추적 가능
        - aws sdk를 이용해서 추적 매커니즘 추가
        - x-ray에 정확히 엑세스할 수 있는지 확인 필요
- VPC 배포
    - 람다는 cloud에 있는데 cloud안에 vpc에는 접근 못하기에 동작을 안함
    - vpc에서 배포하면 가능 -> external 인터넷에 접근 못함
        - 람다가 public subnet의 nat에 배포하고 gateway를 통해서 외부와 접촉 
- 동기 호출
    - cli sdk api 사용시 동기 호출 발생
    - 결과가 바로 나오고 오류가 클라이언트 측에 전달
- 비동기 호출
    - sns s3 eventbridge 등 비동기적으로 호출
    - 람다에 오류가 있으면 3번까지 재수행
    - 여러번 실행될 경우 같은 프로세싱디 되도록 설정
    - dlq 정의를 통해서 실패시 sns나 sqs로 전달

## load balancer
- 관리형 로드 밸런서는 4가지. 최신형을 쓰는게 더 좋음
    - classic load balancer (http https tcp ssl)
    - application load balancer (http https websocker)
    - network load balancer (tcp tls udp)
    - gateway load balancer (ip protool)
- classic load balancer
    - layer7인 http와 layer4인 tcp 수준에 존재. ssl 기반도 포함
    - 1개의 ssl 인증서만 지원.
    - san(subject alternate name) 추가 or 삭제 시 san으로 된 ssl 인증서를 업뎃 해야함
    - 위는 힘들기에 되도록 sni(server name indication)가 있는 신형 alb 권장
    - 별도의 ssl 인증서를 갖길 원하면 다수의 classic load balancer를 사용해야함
    - ssl 인증이 ec2 수준에서 이루어짐. tcp -> tcp 패스가 유일한 2way 인증 방식 
- application load balancer
    - layer7인 http
    - 다수의 머신에 걸쳐 로드 밸런싱을 할 수가 있음
    - 동일한 머신의 다수의 컨테이너에 대해 로드 밸런싱을 할 수 있음
    - websocker 프로토콜 뿐만이 아니라 http버전 2도 지원
    - alb target group
        - EC2 instance - http
        - ECS tasks - http
        - lambda funtion - http request가 json event로 전달
        - ip address - private ip 만 가능
- network load balancer
    - layer4인 tcp udp
    - 초당 수백만 요청 처리
    - 딜레이가 적음. 보통은 400ms, nlb는 100ms
    - 가용 영역당 1개의 정적 ip를 받음. nlb가 퍼블릭이면 탄력적 ip를 퍼블릭 ip로 받음
    - 무료 아님
    - nlb target group
        - EC2 instance 
        - ip address - private ip 만 가능
        - application load balaner
- gateway load balancer
    - 3rd party 네트워크 가상 기기를 aws에서 배포, 스케일링, 관리에 사용
    - 방화벽, 침입 탐지, 예방 체계, 딥 패킷 검사 시스템, 페이로드 조작 등
    - layer3인 ip
    - 투명한 네트워크 게이트: 진입점, 진출점을 제공
    - load balancer: 트래픽을 가장 앱에 분배
    - 기술적으로 6081번 포트에서 GENEVE 프로토콜을 사용
- 교차 영역 밸런싱
    - 각각의 가용영역의 인스턴스를 고르게 분산
    - A 영역에 2개의 EC2, B영역에 8개의 EC2가 있으면 모두 10%만큼 할당
    - claasic load balancer
        - 기본적으로 비활성화
        - AZ에 대해서 무료
    - application load balancer
        - 항상 켜져있음 (못끔)
        - AZ에 대해서 무료
    - network load balancer
        - 기본적으로 비활성화
        - 활성화하면 유료
    - gateway load balancer
        - 기본적으로 비활성화
        - 활성화하면 유료
- sticky session (session affinity)
    - 탄력적 로드 밸런서
    - 요청한 클라이언트가 동일한 인스턴스로 배정
    - classic / application load balaner에서 작동
    - 쿠기를 사용해서 만료일 설정
    - 사용자가 로그인 정보를 잃지 않기 위해서 동일한 인스턴스에 접속 유도
    - 악성 유저가 있을 경우 불균형 발생 가능성 있음
- 라우팅 알고리즘
    - 최저 잔여 요청
        - 미완료 개수가 가장 적은 인스턴스에 요청 배정
        - application / classic load balaner와 일함
    - 라운드 로빈
        - 동일하게 받음
        - application / classic load balaner와 일함
    - flow hash
        - ip, port, tcp seq num 등의 정보들의 hash 결과를 기준으로 타겟 선택
        - tcp udp 연결이 지속될 경우 하나의 타겟에 라우팅
        - network load balancer와 일함

## api gateway
- 클라이언트에게 rest api를 노출
- lambda, http, aws servie 노출 지원
- 29초 제한이 존재
    - 람다가 29초 이상의 시간 제한이 있어도 gateway 사용시 이전에 끝내야함
- 10mb 크기 용량 제한
- 배포 단계
    - 단계를 원하는 만큼 생성 가능
    - dev prod 등 이름 설정 가능
    - 롤백으로 복구 가능 배포 기록도 가능
- 통합
    - http 유형 통합
        - 백엔드에 http가 노출되는 경우가 있음
        - 비율 제한, 캐싱 기능, 사용자 인증, api 키 등의 기능 추가를 위해 api gateway를 추가함
    - lambda function
        - lambda 함수를 불러옴
        - rest api를 쉽게 생성 가능
    - aws service
        - aws의 특정 api 노출 가능
        - step function 워크플로우 시작, sqs 메시지 게시 등에 사용
        - 권한 추가, 공개 배포, 비율 제어 등의 작업에 사용됨
- 예시 gateway를 이용해 s3에 10mb 이상의 데이터 넣기
    - 단순히 gateway는 용량 제한으로 불가
    - gateway, s3 사이에 lambda를 두고 람다가 s3로부터 미리 서명된 url 생성
    - url이 작은 rul은 반환하고 gateway를 통해 client로 전달
    - client는 해당 url를 이용해 파일 업로드
- endpoint type
    - edge-optimized
        - 디폴트, 글로벌 client
        - cloudfront 엣지 위치로 요청을 라우팅
        - 지연 시간을 향상할 수 있어서 글로벌 클라이언트가 있는 경우에 유용
        - api gateway는 한 지역에만 존재
    - regional
        - 모든 클라이언트가 동일 리전에 있어야함
        - cloudfront와 수동으로 결합해 캐싱 전략이나 배포에 제어 권한을 얻음
    - private
        - vpc에만 프라이빗으로 배포해서 eni로부터 액세스를 얻도록 설정 가능
        - gateway에 대한 리소스 정책 사용
- api 응답
    - 캐싱하는 이유 - 백엔드로 가는 호출의 수를 줄이기 위함
    - 백엔드에 대한 요청 발행 전 캐시에서 확인
    - 캐시 미스의 경우 캐시에 저장을 함
    - 기본적은 5분동안 살아남음, 최대 1시간으로 설정 가능
    - 캐시는 단계별로 정의
    - 매서드당 캐시 설정을 다르게 할 수도 있음 (get 매서드, put 매서드 설정 따로)
    - 클라이언트도 캐시 취소 가능 (cache-control: max-age=0으로)
    - 전체 캐시를 플러시도 가능(즉시 취소 가능) - 특정 시점에 캐시 재생성 가능
    - 캐시 암호화 가능
    - 0.5 gb에서 237gb 지정 가능
- 에러 
    - 4xx: clinet 오류
        - 400: bad request
        - 403: access deny
        - 429: 할당량 초과
    - 5xx: server 오류
        - 502: bad gateway exception: lambda 함수가 잘못된 값, 로드가 많이서 호출 잘못 등
        - 503: service unavailable : 백엔드 응답 x
        - 504: integration failure: 29초 초과 
- 보안
    - ssl 인증서 로드 가능
    - CNAME 정의시 route 53 사용 가능
    - s3와 동일한 리소스 정책
        - 사용자 계정, ip, VPC, VPC endpoint 등
    - iam 롤
    - CORS(교차 오리진 리소스 쉐어)
        - 브라우저 기반 보안
        - api 호출 도메인 제어 가능
- 인증
    - iam 기반 엑세스
    - lambda 기반 권한 부여(사용자 지정 권한 부여)
        - lambda 함수를 이용해 사용자 지정 인증 토근 검증
        - lambda 함수 프로그래밍 필요
    - cognito 유저 풀
        - cognito를 통해서 인증
        - 토근을 받고 인증을 허가받음
        - clinet가 먼저 cognito로부터 허가를 받고 토큰을 받아야함
- 로깅 모니터링 추적
    - cloudwaych logs: error or info
        - 전체 요청과 응답 데이터 로그 가능
        - appi gateway 액세스 로그
    - cloudwaych metrics
        - 상세 지표 활성화
    - x-ray
        - 요청에 대한 지연 시간 등을 확인 가능
- 플랜 & api keys
    - 사용 계획
        - api 스테이지와 메서드가 누가 엑세스 가능한지
        - 얼마나 빠르게 엑세스할 수 있는지 정의
        - api키를 사용해서 clinet 식별, 엑세스를 측정 가능
        - 개별 클라이언트에게 한도 설정 가능
    - api keys
        - 앒파벳 숫자 문자열
        - 비밀이고 고객에게 제공
        - 스로틀링 한도 적용 가능, 최대 요청 개수도 제한 가능
    - 429 too many request
        - 리전안에 있는 모든 api에 대한 throttling이 넘침
        - 재시도 매커니즘을 구현해 백오프를 해서 다시 작동해야함
- websocket
    - 브라우저와 서버 간의 양방향 대화형 커뮤니케이션
    - 서버는 클라이언트에게 푸시해서 상태가 있는 앱을 사용 가능
    - websocket api는 채팅 앱, 협업 플랫폼, 게임, 금융 거래 등 사용
    - lambda, dynamodb등과 같이 일함
    - 클라이언트에게는 @connections를 이용해 대답을 보냄
        - 각각의 요청에 대해서 응답으로 callback url을 받음
        - @connections 핸들을 이용해서 받을 수가 있음
        - 람다 함수는 해당 url에 post를 하고 다시 client로 보냄
- private api
    - vpc로부터만 액세스 가능
    - api gateway resource policy 정의 가능
        - 리소스 정책 자체가 api gateway에 첨부
        - 선택된 vpc와 엔드포인트에서 오는 api에 대한 액세스 선별 가능
        - aws:sourceVPC and aws:SourceVpce에서 정책 설정 가능

## appsync
- 백엔드에서 graphQL을 사용하는 관리형 서비스
- graphQL은 앱이 필요한 데이터를 쉽게 받음
- 다수의 소스에서 오는 조합된 데이터를 포함함
- nosql, rdb, elasticsearch 등
- websocket or websocket의 mqtt를 이용한 실시간 데이터임
- 로컬 데이터에 엑세스하고 동기화 하능
- 구조
    - appsync안에 graphSQ schema와 resolvers가 존재
    - resolvers는 다양한 데이터 소스를 받아와 변환시켜줌
    - cloudwatch로 모니터링
- cognito 통합
    - cognito 유저의 그룹을 통해 인증 가능

## Route 53
- 레코드 유형
    - A: 호스트 이름을 ipv4로 매핑
    - AAAA: 호스트 이름을 ipv6로 매핑
    - CNAME: 호스트이름을 다른 호스트이름으로 매핑
        - A or AAAA를 타겟으로 잡아야함
        - DNS 공간의 최상단 노드, Zone Apex에는 생성 불가
        - ex.com에는 불가능, www.ex.com에는 가능
    - NS: 호스트 영역에 대한 이름 서버. 트래픽이 어떤 도메인으로 라우팅되는 방식 제어
- A 레코드
    - client가 route 53에 도메인 입력 후 ip4를 받음
    - 받음 ip 덕분에 aws ec2 public ip로 접근 가능
- CNAME as Alias
    - 모든 aws resource는 aws hostname을 노출
    - CNAME은 호스트이름간 매핑하므로 (xxx.ex1.com -> yyy.ex2.com으로 매핑 가능)
        - 루트가 아닌 도메인에만 적용 (xxx.mydomain.com 형태여야함)
    - alias는 aws 자원만 호스트이름으로 지정 (xxx.ex1.com -> bbb.amazonaws.com)
        - 루트, 비루트 도메인 모두 적용 (ex1.com 형태도 가능)
        - 무료, 네이티브 상태 확인도 제공
- alias record target
    - EC2 DNS를 제외하고 대부분 가능
    - elasti load balancer, cloudfront distribution, api gateway, s3 website, vpc endpoint 등
- ttl(time to live) 유지 시간
    - ttl 만료시 레코드가 갱신됨
    - ttl 살아 있을 동안은 레코드가 클라에 저장
    - alias 레코드를 제외하고 모든 dns 레코드에는 ttl이 필수
- 정책
    - simple 정책
        - health check와 무관한 유일한 정책
        - 트래픽을 하나의 리소스로 라우팅
        - 여러 값이 리턴될 경우, 무작위 값을 정함
    - weighted 정책
        - 특정 리소스로 가능 요청 비율을 설정 가능
        - 70%는 ec2 1번, 30%는 ec2 2번 이런식으로
        - health check과 연관 가능
        - 리전 간 로드 밸런스 등에 사용 가능
    - latency-based 정책 
        - layency가 가깝고 최소인 리소스로 리디렉션
        - 유저와 aws 리전 사이의 트래픽을 근거로 함
        - 미국과 가까운 지역은 미국 aws 지역으로 매핑되는 식임
- geolocation
    - 사용자 위치 자체를 기초로 라우팅
    - latency based와 다름
    - 구체적으로 위치를 지정 가능
    - 매칭 위치가 없으면 디폴트 레코드를 만듦
    - 웹사이트 로컬라이제이션이나 콘텐츠 배포 제한 , 로드 밸런싱 등
- geoproximity
    - 사용자와 리소스의 지리적 위치를 기준으로 리소스에 라우팅
    - bias를 정의해 숫자를 기준으로 트래픽을 어떤 리소스로 이전 가능
    - bias 값을 수정 가능. 클수록 더 많이 끌어옴
    - route 53의 traffic flow 기능을 사용해야함
- traffic flow
    - route 53의 기능
    - geoproximity를 사용 가능하고, 복잡하고 큰 레코드 생성 및 유지 가능
    - 시각적 편집기고 의사결정 트리 제공
    - config가 traffic flow policy로 정해짐
- multi-value
    - 다수의 리소스 라우팅시 사용
    - route 53은 다수의 값 리턴
    - health check를 통해 살아있는 리소스에 대한 값만 리턴하도록 설정
    - 최대 8개 값을 리턴
    - 로드 밸런서를 대체하지는 않음
- ip-based 라우팅
    - 클라 ip 주소를 기준으로 라우팅
    - ip범위인 cidr 목록 정의
    - 어떤 위치로 트래픽이 전송되어야하는지 알 수가 있음
    - 활용 사례는 성능 ㅚ적화, 네트워크 코스트 감소
- 호스트 존
    - 트래픽을 도메인과 서브 도메인으로 라우팅하는 방법을 정의
    - public hosted zone
        - 인터넷으로 매핑해줌
        - application.i.mypublicdomain.com
    - private hosted zone
        - vpc 안에서만 매핑하고 프라이빗 url 정의
        - applicationi.company.internal
- 기타 정보
    - 프라이빗 DNS가 있으면 VPC 셋팅에서 enableDnsHostnames, enableDnsSupport를 커야함
    - route 53은 DBS 보안 extension (DNSSEC) 지원
        - dns 데이터 무결성과 오리진을 확인하는 프로토콜
        - 중간자 공격으로부터 보호
        - public hosted zone에서만 작동
    - 제3 registrar를 이용해서 route 53 사용 가능
        - aws 외부의 도메인을 구입하지만, 여전히 route 53을 사용
        - 레지스트라에서 레코드를 업데이터하고 aws 지시
- health check
    - http health check는 public resources에 대해서 작동
    - health check 종류
        - endpoint를 모니터링 
            - 앱, 서버, aws 리소스
            - endpoint로 http request를 보내서 응답이 2xx or 3xx면 성공
            - 응답의 first 5120 bytes를 기준으로 pass fail를 설정할 수도 있음
        - 다른 health check를 모니터링 (calculated health check라고 불림)
            - 여러 health check 결과를 조합해 하나의 health check로 만듦
            - or and not 조건 사용
            - 256개의 health check를 사용 가능
        - cloudwatch 알람 모니터링
    - private hosted zone에 대한 health check
        - vpc나 on-premises 리소스 같은 곳에 엑세스 불가능
        - cloudwatch metric를 만들고 cloudwatch alarm와 연결해서 체크 가능

## 하이브리드 DNS
- route 53 resolver는 기본적으로 EC2 인스턴스, private hosted zone, public name server에 응답 가능
- resolver endpoint
    - inbound endpoint
        - 외부 네트워크의 dns 리졸버가 dns 쿼리를 route 53으로 보내고 응답
        - 도메인 명이나 private hosted zone의 레코드를 읽는데 사용
    - outbound endpoint
        - dns 쿼리를 온프레미스 dns 리졸버에 전달
        - 리졸버 규칙을 사용
    - 두개 이상의 az를 만들어 높은 가용성 유지
    - 초당 10000회의 쿼리 지원 
    - aws 리전에 1개 이상의 vpc와 관련
    
## aws outposts
- hybrid cloud: 온프레미스 인프라와 클라우드 인프라를 동시에 가짐
- aws outposts는 server raks로 on-premise에서 aws의 인프라, 서비스, 툴을 제공하는 것
- aws는 outposts racks을 on-premise에 설치하고 관리
- outposts rack의 보안을 책임져야함
- on-premise 시스템에 저 latency로 접근 가능

## aws wavelength
- wavelenth zone이란 5g 네트워크 엣지 데이터센터 안에 내장된 인프라 배포물
- 무료
- ex) 스마트 시티, ml 보조 진단, 커넥티드 카, 비디오 스트림, 실시간 게임 등

## aws loalzone
- aws service를 유저와 가깝게 해서 latency에 이점을 얻는 것
- aws 리전을 다수의 근접한 가용 영역으로 확장